from erd import *
from table import *

# This function converts an ERD object into a Database object
# The Database object should correspond to a fully correct implementation
# of the ERD, including both data structure and constraints, such that the
# CREATE TABLE statements generated by the Database object will populate an
# empty MySQL database to exactly implement the conceptual design communicated
# by the ERD.
#
# @TODO: Implement me!
def getMultiplicity( es, r_name ):
    return [con[1] for con in es.connections if con[0]==r_name][0]

def allInList( dep_names, existing_names ):
    for name in dep_names:
        if name not in existing_names:
            return False
    return True

def convert_to_table( erd ):
    tables = []
    
    # Initialize dictionary for each entity set and add parents as dependencies
    dependencies = dict()
    relationship_members = dict()
    no_table = set()
    #for es in erd.entity_sets:
     #   dependencies[es.name] = [(parent, "isA") for parent in es.parents]
    
    for e in erd.entity_sets:
        if len(e.parents) > 0:
            for p in e.parents:
                dependencies[e.name] = [(p, "isA")]
        else:
            dependencies[e.name] = []

    
    # Add one to many relationship dependencies
    for r in erd.relationships:
        #es_in_r = [es for es in erd.entity_sets if r.name in [con[0] for con in es.connections]]
        es_in_r = []
        for es in erd.entity_sets:
            for con in es.connections:
                if r.name in con[0]:
                    es_in_r.append(es)


        #if len(r.primary_key) == 0 and len([es for es in es_in_r if getMultiplicity(es, r.name) == Multiplicity.MANY]) == 1:
        count = 0
        for es in es_in_r:
            if getMultiplicity(es, r.name) == Multiplicity.MANY:
                count += 1
        if len(r.primary_key) == 0 and count == 1:


            #es_many = [es.name for es in es_in_r if getMultiplicity(es, r.name) == Multiplicity.MANY][0]
            es_many = []
            for es in es_in_r:
                if getMultiplicity(es, r.name) == Multiplicity.MANY:
                    es_many = [es.name][0]

            #es_one = [es.name for es in es_in_r if getMultiplicity(es, r.name) == Multiplicity.ONE]
            es_one = []
            for es in es_in_r:
                    if getMultiplicity(es, r.name) == Multiplicity.ONE:
                        es_one.append(es.name)

            for es in es_one:
                dependencies[es_many].append((es, r.name))
            no_table |= {r.name}

        elif len(es_in_r) == 1:
            #if len([es for es in erd.entity_sets if r.name in es.supporting_relations]) != 0:
            count = 0
            for es in erd.entity_sets:
                if r.name in es.supporting_relations:
                    count += 1
            if count !=0:

                #dependencies[[es for es in erd.entity_sets if r.name in es.supporting_relations][0].name].append((es_in_r[0].name, r.name))
                for es in erd.entity_sets:
                    if r.name in es.supporting_relations:
                        dependencies[[es][0].name].append((es_in_r[0].name, r.name))
            no_table |= {r.name}
            
        relationship_members[r.name] = [(es.name, getMultiplicity(es, r.name)) for es in es_in_r]
        
    # Create tables for entity sets
    entity_sets = list(erd.entity_sets)
    while len(entity_sets) != 0:
        # find an entity set with no dependencies
        entity_set = None
        counter = 0
        for es in entity_sets:
            if counter > 1000:
                raise Exception("Too many iterations, ERD dependency cycle (unsupported) likely.")
            else:
                counter += 1

            if allInList([d[0] for d in dependencies[es.name]], [t.name for t in tables]):
                entity_set = es
                entity_sets.remove(es)
                break
        
        # Initialize table values
        attrs = set(entity_set.attributes)
        f_keys = set()
        p_keys = set(entity_set.primary_key)
        
        # determine foreign keys
        for d in dependencies[entity_set.name]:
            keys = [table for table in tables if table.name == d[0]][0].primary_key
            f_keys |= set([(tuple(keys), d[0], tuple(keys))])
            attrs |= keys
            if d[1] == "isA":
                p_keys |= keys
            elif d[1] in entity_set.supporting_relations:
                p_keys |= keys
                attrs |= set([rel for rel in erd.relationships if rel.name == d[1]][0].attributes)                

        tables += [Table(entity_set.name, attrs, p_keys, f_keys)]

    # Implement any relationship that requires a table
    for rel in [r for r in erd.relationships if r.name not in no_table]:
        attrs = set(rel.attributes)
        p_keys = set(rel.primary_key)
        f_keys = set()
        for table in [t for t in tables if t.name in [mem[0] for mem in relationship_members[rel.name]]]:
            attrs |= table.primary_key
            f_keys |= set([(tuple(table.primary_key), table.name, tuple(table.primary_key))])
            if [mem for mem in relationship_members[rel.name] if mem[0] == table.name][0][1] == Multiplicity.MANY:
                p_keys |= table.primary_key
        tables += [Table(rel.name, attrs, p_keys, f_keys)]

    return Database(tables)